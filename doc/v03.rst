
==================
Version 3 Refactor
==================

Abstract Goals:

* Absolute configuration compatibility (upward compatible.)
  including all plugins.

* multi-protocol support.
  ability to put in urls for mqtt, or different amqp libraries, perhaps others.

* internally represent things in v03 messages, have something build
  v02 ones for compatibility, but operate in v03.

* less code, simpler code.
  more readable, elegant, pythonic code.
  make maintenance easier. 

while you're at it
------------------

goals of opportunity:

  * add stuff to make it work as an API?
  * potentially new plugin api to allow groups (of messages and/or files.)
  * Finish off log rotation.
  * Assume python >= 3.4 remove old cruft.
  * Assume ubuntu >= 18.04 remove old cruft.
  * Assume systemd, remove sysv integration.
  * have options adopt camelCase where possible.
 
V02 Plugin Pain Points
----------------------

Writing plugins should be a straight-forward thing for people with a rudimentary
knowledge of python, and some understanding of the task at hand. in version 2,
writing plugins is a lot harder than it should be.  

* syntax error, v2 gives basically a binary response, either reading in the plugin worked
  or it didn't... it is very unfriendly compared to normal python.

* when a setting is put in a config file, it's value is [ value ], and not value (It's in a list.)

* weird scoping issue of import (import in main does not carry over to on_messag, need to import again.)
  what the heck is self, what the heck is parent?  these are not obvious in the plugins.

* bizarre use of python logger API... self.logger? wha?

* inability to call from python code (no API.)

* inability to *add* messages within a plugin (can only process the message you have.)

* inability to process groups of messages at a time (say for concurrent sends or 
  downloads, rather than just one at time.

* poor handling of message acknowledgements. v02 just ackowledges the previous message 
  when a new one is received.

* lack of clarity about options, versus working variables, because they are in the same namespace
  in a plugin, if you find self.setting==True  ... is that because the application set it somewhere, 
  or because an option was set by a client... is it a setting or a variable?

* making changes to messages is a bit complicated, because they evolved over different message formats.


Changes planned to address pain points
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* use importlib from python, much more standard way to register plugins.
  now syntax errors will be picked up just like any other python module being imported,
  with a reasonable error message.

* no strange decoration at end of plugins (self.plugin = , etc... just plain python.)

* The strange choice of *parent* as a place for storing settings is puzzling to people.
  *parent* instance variable becomes *options*,  *self.parent* becomes *self.o*
   
* plural event callbacks replace singular ones.  on_messages replaces on_message

* messages are just python dictionaries. fields defined by json.loads( v03 payload format )
  messages only contain the actual fields, no settings or other things...
  plain data.
 
* callbacks move messages between worklists. A worklist is just a list of messages. There are four:

  * worklist.incoming -- messages yet to be processed.
  * worklist.rejected -- message which are not to be further processed.
  * worklist.ok -- messages which have been successfully processed.
  * worklist.retry   -- messages for which processing was attempted, but it failed.

* acknowledgements done more pro-actively.

* add scoping mechanism to define plugin properties.

* properties fed to __init__ of the plugin,  parent is gone from the plugins, they should
  just refer to self.o for the options/settings they need. (self.o clearly separates options
  from working data.)

* command-line parsing using python standard argParse library.  Means that keywords no longer work
  with a single -.  Settling on standard use of -- for word based options, and - for abbrevs.
  examples:  Good: --config, and -c, BAD: -config --c .



Ship of Theseus
---------------

It might be that the re-factoring inherent in v03 results in a 
Ship of Theseus, where it works the same way as v02, but all
the parts are different... obviously a concern/risk... 
might be a feature.

Now that we are a good way throught the process, a
mapping of source code transcriptions between
the two versions, is clear:

+--------------------------+---------------------------+
| Version 2 file           | Version 3 file            |
+--------------------------+---------------------------+
| sr_config.py             | config.py                 |
+--------------------------+---------------------------+
| sr_instances.py          | sr.py for most mgmt.      |
|                          | instance.py single proc   |
|                          |                           |
+--------------------------+---------------------------+
| sr_consumer.py           | moth/__init__.py          |
|                          |                           |
| sr_amqp.py               | moth/amqp.py              |
|                          |                           |
| sr_message.py            |                           |
+--------------------------+---------------------------+
| sr_checksum.py           | plugin/integrity/         |
|                          |      __init__.py          |
| sum/*                    |      *                    |
+--------------------------+---------------------------+
| sr_cache.py              | plugin/nodupe.py          |
+--------------------------+---------------------------+
| sr_retry.py              | plugin/retry.py           |
+--------------------------+---------------------------+
| sr_post.py               | plugin/gather/file.py     |
|                          |                           |
|                          | flow/post.py              |
+--------------------------+---------------------------+
| sr_poll.py               | plugin/gather/remote.py   |
|                          |                           |
|                          | flow/poll.py              |
+--------------------------+---------------------------+
|                          | transfer/__init__.py      |
| sr_util.py/sr_proto      |  * transfer.Protocol      |
| sr_util.py/sr_transport  |  * transfer.Transport     |
|                          |                           |
| sr_file.py               | transfer/file.py          |
|                          |                           |
| sr_ftp.py                | transfer/ftp.py           |
|                          |                           |
| sr_http.py               | transfer/http.py          |
|                          |                           |
| sr_sftp.py               | transfer/sftp.py          |
|                          |                           |
+--------------------------+---------------------------+
| plugins/                 | plugin/                   |
+--------------------------+---------------------------+
| overall flow             | flow/__init__             |
+--------------------------+---------------------------+
| sr_subscribe.py          | flow/subscribe.py         |
|                          |                           |
| sr_shovel.py             | flow/shovel.py            |
|                          |                           |
| sr_winnow.py             | flow/winnow.py            |
|                          |                           |
| sr_report.py             | flow/report.py            |
|                          |                           |
| sr_sarra.py              | flow/sarra.py             |
+--------------------------+---------------------------+


Mappings
~~~~~~~~

v2->v3 instance variables::

    self.user_cache_dir --> self.o.cfg_run_dir


Dictionaries or Members for Properties?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There seems to be a tension between using class members and dictionaries
for settings.  members seem more convenient, but harder to manipulate,
though we have equivalent idioms. Argparse returns options as their own
members of this parsing object.  There is a hierarchy to reconcile:

* protocol defaults
* consumer defaults
* component defaults
* configuration settings (overrides)
* command line options (overrides)

resolving them to apply overrides, mais more sense as operations
on dictionaries, printing, saving loading, again makes more sense
as dictionaries.  In code, members are slightly shorter, and perhaps
more idiomatic:: 

   hasattr(cfg,'member') vs. 'member' in cfg (dictionary)

What makes more sense... Does it make any practical difference?
not sure... need to keep the members for places where
plugins are called, but can use properties elsewhere, if desired.

Known Problems
--------------

* passing of logs around is really odd. we didn't understand what 
  python logging objects were. Need to use them in the normal way.
  new modules are built that way...

* this weird try/except thing for importing modules... tried removing
  it but it broke parsing of checksums... sigh... have to spend time
  on specifically that problem. On new modules ( sarra.config, 
  sarra.tmpc.*, sr.py ) using normal imports. likely need to
  refactor how checksum plugin mechanism works then try again.


Concrete Plan
-------------

replace sarra/sr_config with sarra/sr_cfg2. The new sr_cfg2 uses argparse 
and a simpler model for config file parsing. This became config.py

make sr.py accept operations on subsets, so it becomes the unique entry point.
internalize implementation of all management stuff, declare etc...

HMPC - Topic Message Protocol Client... a generalization of the message
passing library with a simplified API.  abstracts the protocol differences
away. (This later became the Moth module.)


Progress
--------

The functionality of sr_amqp.py is completely reproduced in TMPC/amqp.py 
(but not yet used, except by sr.py.) All the important logic is preserved, 
but it is transcribed into new classes. Should have identical 
failure recovery behaviour.  This is working in a demo form. To 
reproduce, fire up sr_insects, run setup. and the configurations will 
be installed.

sr_cfg2.py is still a stub, it has a lot of features and options, but
it isn't clear how to expand it to all of them. the thing about instances
inheriting from configure... it is odd, but hard to see how changing that
will not break everything, plugin-wise... thinking about having defaults
distributed to the classes that use the settings, and having something
that brings them together, instead of one massive config thing.
renamed to config.py (aka: sarra.config) and exercising it with
sr.py 

Thinking about replacing sr_consumer with a new class that implements the
General Algorithm describe in `Concepts <Concepts.rst#the-general-algorithm>`
this happenned and became the Flow Module, and *the General Algorithm* got 
renamed *the Flow Algorithm*

Thinking about just removing the sr\_ prefix from classes for replacements,
since they are in sarra directory anyways. so have an internal class 
sarra/instances, sarra/sarra <- replace consumer... This happenned
and became a place holder for progress.

Added configuration selection to sr.py (e.g. subscribe/\*) and 
*setup*, and *cleanup* options. 

add/remove/enable/disable/edit done.

'log' dropped for now... (which log ?)

added list, show, and built prototype shovel... required
a instance (sets state files and logs) and then calls flow... 
flow/run() is visibly  the general algorithm,
shovel is a sub-class of flow.

Got a skeleton for v2 plugins working (v2wrapper.py)
implemented import-based and group oriented v3 plugin framework. ( #213 )

cache (now called noDupe) working.

re-wrote how the v3 plugins work to use worklists, and then re-cast
cache and v2plugins as plugins themselves.

renamed message queue abstract class from tmpc to moth
(what does a Sarracenia eat?)

With shovel and winnow replaced by new implementations, it passes
the dynamic flow test, including the Retry module ported to v3, and
a number of v2 modules used as-is.

Completed an initial version of the sr_post component now (in v3: plugin.gather.file.File)
Now working on sr_poll, which will take a while because it involve refactoring: sr_file, sr_http,
sr_ftp, sr_sftp into the transfer module





FIXME
-----

FIXME are things left to the side that need to be seen to.

* changed behaviour of 'sr list' , 'sr list examples' needs to be documented.

* new command 'sr show' needs to be documented. 

* scopable properties for internal classes, like they exist for plugins.

* took the code required to implement set_newMessageFields verbatim from v2.
  It is pretty hairy... perhaps turn into a plugin, to get it out of the 
  main code?  Don't think it will ever go away.  It is fairly ugly, but 
  very useful and heavily used in existing configs. probably OK. 

Incompatibilities
-----------------

There are not supposed to be any. This is a running list of things to fix or document.
breaking changes:

* loglevel none -> loglevel notset (now passing loglevel setting directly to python logging module, none isn't defined.)

* log messages and output in interactive, will be completely different.

* dropping on_watch plugins. afaict, no-one uses them.  The way v03 works it would be an on_message for a watch.
  makes more sense that way anyways.

* plugins that access internals of sr_retry need to be rewritten, as the class is now plugin/retry.py.

Features
--------

* sarra.plugin API is now vanilla python with no magic settings. just standard classes, using standard import mechanism.
  debugging should be much simpler now as the interpreter will provide much better error messages on startup.

* properties/options for classes are now hierarchical, so can set debug to specific classes within app.

* sarra.moth class abstracts away AMQP, so messaging protocol becomes pluggable.

* use the sarra. prefix (already present) to replace sr\_ prefix on modules.

* API access to flows.

* sr ability to select multiple components and configurations to operate on.

* messages are acknowledged more quickly, should help with throughput.

* plugin API are now based on groups of messages, rather than individual ones, allowing people
  to organize concurrent work.

* integrity (checksums) are now plugins.

* gather (inlet? sources of messages) are now plugins.


