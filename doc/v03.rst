
==================
Version 3 Refactor
==================

Abstract Goals:

* Absolute configuration compatibility (upward compatible.)
  including all plugins.

* multi-protocol support.
  ability to put in urls for mqtt, or different amqp libraries, perhaps others.

* internally represent things in v03 messages, have something build
  v02 ones for compatibility, but operate in v03.

* less code, simpler code.
  more readable, elegant, pythonic code.
  make maintenance easier. 

while you're at it
------------------

goals of opportunity:

  * add stuff to make it work as an API?
  * potentially new plugin api to allow groups (of messages and/or files.)
  * Finish off log rotation.
  * Assume python >= 3.4 remove old cruft.
  * Assume ubuntu >= 18.04 remove old cruft.
  * Assume systemd, remove sysv integration.
  * have options adopt camelCase where possible.
 
V02 Plugin Pain Points
----------------------

Writing plugins should be a straight-forward thing for people with a rudimentary
knowledge of python, and some understanding of the task at hand. in version 2,
writing plugins is a lot harder than it should be.  

* syntax error, v2 gives basically a binary response, either reading in the plugin worked
  or it didn't... it is very unfriendly compared to normal python.

* when a setting is put in a config file, it's value is [ value ], and not value (It's in a list.)

* weird scoping issue of import (import in main does not carry over to on_messag, need to import again.)
  what the heck is self, what the heck is parent?  these are not obvious in the plugins.

* bizarre use of python logger API... self.logger? wha?

* inability to call from python code (no API.)

* inability to *add* messages within a plugin (can only process the message you have.)

* inability to process groups of messages at a time (say for concurrent sends or 
  downloads, rather than just one at time.

* poor handling of message acknowledgements. v02 just ackowledges the previous message 
  when a new one is received.

* lack of clarity about options, versus working variables, because they are in the same namespace
  in a plugin, if you find self.setting==True  ... is that because the application set it somewhere, 
  or because an option was set by a client... is it a setting or a variable?

* making changes to messages is a bit complicated, because they evolved over different message formats.


Changes planned to address pain points
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* use importlib from python, much more standard way to register plugins.
  now syntax errors will be picked up just like any other python module being imported,
  with a reasonable error message.

* no strange decoration at end of plugins (self.plugin = , etc... just plain python.)

* The strange choice of *parent* as a place for storing settings is puzzling to people.
  *parent* instance variable becomes *options*,  *self.parent* becomes *self.o*
   
* plural event callbacks replace singular ones.  on_messages replaces on_message

* messages are just python dictionaries. fields defined by json.loads( v03 payload format )
  messages only contain the actual fields, no settings or other things...
  plain data.
 
* callbacks move messages between worklists. A worklist is just a list of messages. There are four:

  * worklist.incoming -- messages yet to be processed.
  * worklist.rejected -- message which are not to be further processed.
  * worklist.ok -- messages which have been successfully processed.
  * worklist.retry   -- messages for which processing was attempted, but it failed.

  could add others... significant number of applications for something like *deferred*

* acknowledgements done more pro-actively.

* add scoping mechanism to define plugin properties.

* properties fed to __init__ of the plugin,  parent is gone from the plugins, they should
  just refer to self.o for the options/settings they need. (self.o clearly separates options
  from working data.)

* command-line parsing using python standard argParse library.  Means that keywords no longer work
  with a single -.  Settling on standard use of -- for word based options, and - for abbrevs.
  examples:  Good: --config, and -c, BAD: -config --c .



Ship of Theseus
---------------

It might be that the re-factoring inherent in v03 results in a 
Ship of Theseus, where it works the same way as v02, but all
the parts are different... obviously a concern/risk... 
might be a feature.

Now that we are a good way throught the process, a
mapping of source code transcriptions between
the two versions, is clear:

+--------------------------+---------------------------+
| Version 2 file           | Version 3 file            |
+--------------------------+---------------------------+
| sr_config.py             | config.py                 |
+--------------------------+---------------------------+
| sr_instances.py          | sr.py for most mgmt.      |
|                          | instance.py single proc   |
|                          |                           |
+--------------------------+---------------------------+
| sr_consumer.py           | moth/__init__.py          |
|                          |                           |
| sr_amqp.py               | moth/amqp.py              |
|                          |                           |
| sr_message.py            |                           |
+--------------------------+---------------------------+
| sr_checksum.py           | plugin/integrity/         |
|                          |      __init__.py          |
| sum/*                    |      *                    |
+--------------------------+---------------------------+
| sr_cache.py              | plugin/nodupe.py          |
+--------------------------+---------------------------+
| sr_retry.py              | plugin/retry.py           |
+--------------------------+---------------------------+
| sr_post.py               | plugin/gather/file.py     |
|                          |                           |
|                          | flow/post.py              |
+--------------------------+---------------------------+
| sr_poll.py               | plugin/gather/remote.py   |
|                          |                           |
|                          | flow/poll.py              |
+--------------------------+---------------------------+
|                          | transfer/__init__.py      |
| sr_util.py/sr_proto      |  * transfer.Protocol      |
|                          |                           |
| sr_util.py/sr_transport  | flow/__init__.py          |
|                          |                           |
| sr_file.py               | transfer/file.py          |
|                          |                           |
| sr_ftp.py                | transfer/ftp.py           |
|                          |                           |
| sr_http.py               | transfer/http.py          |
|                          |                           |
| sr_sftp.py               | transfer/sftp.py          |
|                          |                           |
+--------------------------+---------------------------+
| plugins/                 | plugin/                   |
+--------------------------+---------------------------+
| overall flow             | flow/__init__.py          |
+--------------------------+---------------------------+
|                          |                           |
| sr_poll.py               | flow/poll.py              |
|                          |                           |
| sr_post.py               | flow/post.py              |
|                          |                           |
| sr_subscribe.py          | flow/subscribe.py         |
|                          |                           |
| sr_shovel.py             | flow/shovel.py            |
|                          |                           |
| sr_report.py             | flow/report.py            |
|                          |                           |
| sr_sarra.py              | flow/sarra.py             |
|                          |                           |
| sr_sender.py             | flow/sender.py            |
|                          |                           |
| sr_watch.py              | flow/watch.py             |
|                          |                           |
| sr_winnow.py             | flow/winnow.py            |
|                          |                           |
+--------------------------+---------------------------+


Mappings
~~~~~~~~

v2->v3 instance variables::

    self.user_cache_dir --> self.o.cfg_run_dir

Changes needed in v2 plugins::

    from sarra.sr_util import --> from sarra import 



Dictionaries or Members for Properties?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There seems to be a tension between using class members and dictionaries
for settings.  members seem more convenient, but harder to manipulate,
though we have equivalent idioms. Argparse returns options as their own
members of this parsing object.  There is a hierarchy to reconcile:

* protocol defaults
* consumer defaults
* component defaults
* configuration settings (overrides)
* command line options (overrides)

resolving them to apply overrides, mais more sense as operations
on dictionaries, printing, saving loading, again makes more sense
as dictionaries.  In code, members are slightly shorter, and perhaps
more idiomatic:: 

   hasattr(cfg,'member') vs. 'member' in cfg (dictionary)

What makes more sense... Does it make any practical difference?
not sure... need to keep the members for places where
plugins are called, but can use properties elsewhere, if desired.

Known Problems
--------------

* passing of logs around is really odd. we didn't understand what 
  python logging objects were. Need to use them in the normal way.
  new modules are built that way...

  In new modules, use the logging.getLogger( __name__ ) convention, but
  often the name does not match the actual source file...  why?
  e.g. a log message from config.py parsing shows up like::

     2020-08-13 ...  [INFO] sarra.sr_credentials parse_file ... msg text...

  why is it labelled sr_credentials? no idea. 


* this weird try/except thing for importing modules... tried removing
  it but it broke parsing of checksums... sigh... have to spend time
  on specifically that problem. On new modules ( sarra.config, 
  sarra.tmpc.*, sr.py ) using normal imports. likely need to
  refactor how checksum plugin mechanism works then try again.

  totally refactored now. Integrity class is normal.


Concrete Plan
-------------

replace sarra/sr_config with sarra/sr_cfg2. The new sr_cfg2 uses argparse 
and a simpler model for config file parsing. This became config.py

make sr.py accept operations on subsets, so it becomes the unique entry point.
internalize implementation of all management stuff, declare etc...

HMPC - Topic Message Protocol Client... a generalization of the message
passing library with a simplified API.  abstracts the protocol differences
away. (This later became the Moth module.)


Progress
--------

The method of testing is to make modifications, and check them against the 
sr_insects v03_wip branch.  In general, an un-modified sr_insects tests should
work, but since the logs change, there is logic being added on that branch
to parse v2 and v3 versions in the same way.  Thus the v03_wip branch tests
are compatible with both stable and work-in-progress versions.

To get each component working, practice with individual unit tests, and then
get to static-flow tests.  Can also do flakey_broker. The work is only going
that far as all the components are converted.  Once full conversion is achieved,
then will look at dynamic_flow.

Purpose is not a finished product, but a product with sufficient and 
appropriate structure so that tasks can be delegated with reasonable hope of success.


Done
~~~~

The functionality of sr_amqp.py is completely reproduced in TMPC/amqp.py 
(but not yet used, except by sr.py.) All the important logic is preserved, 
but it is transcribed into new classes. Should have identical 
failure recovery behaviour.  This is working in a demo form. To 
reproduce, fire up sr_insects, run setup. and the configurations will 
be installed.

sr_cfg2.py is still a stub, it has a lot of features and options, but
it isn't clear how to expand it to all of them. the thing about instances
inheriting from configure... it is odd, but hard to see how changing that
will not break everything, plugin-wise... thinking about having defaults
distributed to the classes that use the settings, and having something
that brings them together, instead of one massive config thing.
renamed to config.py (aka: sarra.config) and exercising it with
sr.py.  It is now a complete replacement.

Thinking about replacing sr_consumer with a new class that implements the
General Algorithm describe in `Concepts <Concepts.rst#the-general-algorithm>`
this happenned and became the Flow Module, and *the General Algorithm* got 
renamed *the Flow Algorithm*. yes, that is now flow/ class hierarchy.
The main logic is in __init__, and actual components are sub-classes.

Thinking about just removing the sr\_ prefix from classes for replacements,
since they are in sarra directory anyways. so have an internal class 
sarra/instances, sarra/sarra <- replace consumer... This happenned
and became a place holder for progress, meaning that files with sr_
prefix in the name, that are not entry-points, indicate v2 code that
has not yet been retired/replaced.

Added configuration selection to sr.py (e.g. subscribe/\*) and 
*setup*, and *cleanup* options. 

add/remove/enable/disable/edit done.

'log' dropped for now... (which log ?)

added list, show, and built prototype shovel... required
a instance (sets state files and logs) and then calls flow... 
flow/run() is visibly  the general algorithm,
shovel is a sub-class of flow.

Got a skeleton for v2 plugins working (v2wrapper.py)
implemented import-based and group oriented v3 plugin framework. ( #213 )

cache (now called noDupe) working.

re-wrote how the v3 plugins work to use worklists, and then re-cast
cache and v2plugins as plugins themselves.

renamed message queue abstract class from tmpc to moth
(what does a Sarracenia eat?)

With shovel and winnow replaced by new implementations, it passes
the dynamic flow test, including the Retry module ported to v3, and
a number of v2 modules used as-is.

Completed an initial version of the sr_post component now (in v3: plugin.gather.file.File)
Now working on sr_poll, which will take a while because it involve refactoring: sr_file, sr_http,
sr_ftp, sr_sftp into the transfer module

Mostly done sr_subscribe, which, in the old version, is a base class for all other components,
but in v3 is just the first component that actually downloads data. So encountering all
issues with data download, and plugins that do interesting things. Mostly done, but 
plugins not quite working.

sr_sarra was straightforward once sr_subscribe was done.  

re-implemented get plugin to have conventional return value as the number of bytes 
transferred, and if they differ, that signals an issue.

sr_sender send now done, involved a lot more thinking about how to set new_ fields
in messages. but once that was done, was able to remove both the sender and sr_subscribe
(the parent class of most components) and allowed removal of sr_cache, sr_consumer, sr_file,
sr_ftp, sr_http, sr_message, sr_retry, and sr_sftp, sum/*, sr_util.

That's the end of the most difficult part.  


Worries Addressed
~~~~~~~~~~~~~~~~~

This section containts issues that were taken care of.  They were a bother for a while,
so noting down what the solution was.

* logging using __name__ sometimes ends up claiming to be from the wrong file.
  example::  

    2020-08-16 01:31:52,628 [INFO] sarra.sr_credentials set_newMessageFields FIXME new_dir=/home/peter/sarra_devdocroot/download

  set_newMessageFields is in config.py not sr_credentials... why it is doing that?
  Likely wait until all legacy code is replaced before tackling this.
  if this doesn't get fixed, then make it a bug report.

  fixed: note... the problem was that the logger declaration must be AFTER all 
  imports.  Concretely::

    logger = logging.getLogger( __name__ )

  must be placed after all imports.

* sr_audit ? what to do. Removed.

* all non entry_point sr_*.py files can be removed.
  remove sum sub-directory. sr_util.py


in Flux
~~~~~~~

plugin compatiblity under review... decided to re-write the accel_* plugins for v3, and
change the API because the v2 one has fundamental deficiencies:

* the do_get api deals with failure by raising an exception... there is no checking
  of return codes on built-in routines...  It is possiby taken care of by try/except, 
  but would prefer for a normal program flow to be able to trace and
  report when an i/o failure happens (keep try/except to as small a scale as we can.)

* there is a highly... idiosyncratic nature of the do_get, for example in the v2 accel_scp,
  where it calls do_get, and then decides not to run and falls through to the built-in 
  one. This logic is rarely helpful, difficult to explain, and confusing to diagnose
  in practice.


Have re-written accel_wget, and accel_scp to the new api... working through static-flow
to test them. There is also logic to spot v2 invocations of them, and replace with v3
in the configuration.



TODO
~~~~


* likely run code lint thing to fix indentation and PEP style.

* cleanup entry points: sr_audit, sr_tailf, sr_log2save, 

* migrate sr_credentials.py to sarra/credentials.py.

* migrate sr_xattr.py to sarra/xattr.py

* test with dynamic-flow.

* Adjust Programmer's guide to reflect new API.

* update documentation... change everything to use sr3 entry point?
  (See transition point below.)

* get partitioned file transfers working again.

* alarm_set truncates to integers... hmm.. use setitimer instead? 

Not Baked/Thinking
~~~~~~~~~~~~~~~~~~

Structural code things that are not settled, may change.
Probably need to be settled before having anyone else dive in.

* scopable properties for internal classes, like they exist for plugins.

* perhaps move the whole plugin thing up a level (get rid of directory)
  so Plugin becomes a class instantiated in sarra/__init__.py... puts
  plugins and built-in code on a more even level... for example how
  do plugin transfer protocols work?  thinking...

* took the code required to implement set_newMessageFields verbatim from v2.
  It is pretty hairy... perhaps turn into a plugin, to get it out of the 
  main code?  Don't think it will ever go away.  It is fairly ugly, but 
  very useful and heavily used in existing configs. probably OK. 

* tables thinking about *onfly* and *data* checksums... think about how
  they need to interact with do_get/do_put plugins, and how they need
  to be validated. (do we flag an error if onfly does not match? etc...)
  philosophically to be examined.

* until all components are ported, will not try to fix dynamic_flow. 

* As you get stuff working, see if we can work backward to fix
  v2wrapper to get back compatibility, say for do_* routines and such.

* consider transition, life with both versions... should sr.py --> sr3.py ?
  should we have a separate debian package with transition entry points
  (sr_subscribe and friends only included in compat package, and all)
  interactivity natively only happens through sr3?

* changing recovery model, so that all retry/logic is in main loop,
  and moth just returns immediately.  Point being could have multiple
  gathers for multiple upstreams, and get messages from whichever is
  live...
  also end up with a single loop that way... cleaner.

* think about API by sub-classing flow... and having it auto-integrate
  with sr entry point... hmm... likely look at this when updating
  Programmer's Guide.

* more worklists? rename failed -> retry or deferred.  Add a new failed
  where failed represents a permanent failure. and the other represents
  to be retried later.


FIXME/Deferred
~~~~~~~~~~~~~~

The point of the main v3 work is to get a re-factor done to the point where
the code is understandable to new coders, so that tasks can be assigned.
This section includes a mix of tasks that can hopefully be assigned, 

FIXME are things left to the side that need to be seen to.


* **RELEASE BLOCKER** hairy.
  sr_watch does not batch things. It just dumps an entire tree.
  This will need to be re-wored before release into an iterator style approach.
  so if you start in a tree with a million files, it will scan the entire million
  and present them as a single in memory worklist.  This will have performance
  problems.  want to incrementally proceed though lists one 'prefetch' batch
  at a time.

  There is an interim fix to pretend it does batching properly, but the memory
  impact and delay to producing the first file is still there, but at least
  returns one batch at a time.

* **RELEASE BLOCKER** logs of sr_poll and sr_watch tend to get humungous way too quickly.


* try out jsonfile for building messages to post. can build json incrementally,
  so you do not need to delete the _deleteOnPost elements (can just skip over them)


Incompatibilities
-----------------

There are not supposed to be any. This is a running list of things to fix or document.
breaking changes:


* in v3, use -- for full word options, like --config, or --broker.  In v2 you could use -config and -broker,
  but that will end badly in v3.  In the old command line parser, -config, and --config were the same, which 
  was idiosyncratic.  The new
  command line option parser is built on ArgParse, and interprets a single - as prefix a single option where the
  the subsequent letters are and argument.  Example

  -config hoho.conf  -> in v2 refers to loading the hoho.conf file as a configuration.

  in v3, it will be interpreted as -c (config) load the onfig.conf gile, and hoho.conf is part of some subsequent option.

* loglevel none -> loglevel notset (now passing loglevel setting directly to python logging module, none isn't defined.)

* log messages and output in interactive, will be completely different.

* dropping on_watch plugins. afaict, no-one uses them.  The way v03 works it would be an on_message for a watch.
  makes more sense that way anyways.

* plugins that access internals of sr_retry need to be rewritten, as the class is now plugin/retry.py.
  the way to queue something for retry in current plugins is to append them to the failed queue.

* do_download and do_send were 1st pass at *schemed* plugins, I think they should be deprecated/replaced
  by do_get and do_put. unclear whether there is a need for these anymore (download and send plugins are
  at wrong level of abstraction)

* do_download, do_send, do_get, do_put are *schemed* downloads... that is, rather than stacking so that
  all are called, they are registered for particular protocols.  in v2, for example accel_* plugins would
  register the "download" scheme. an on_message entry point would alter the scheme so that the do_* routine
  would be invoked. In v2, the calling signature for all plugins is the same (self, parent) but for
  these do_get and do_put cases, that is quite counter productive. so instead have a calling signature
  identical to built-in protocol get/put... src_file, dst_file, src_offset, dst_offset, len )

* In v2, mirror default settings used to be False in all components except sr_sarra.
  but the mirror setting was not honoured in shovel, and winnow (bug #358) 
  this bug is corrected in v3, but then you notice that the default is wrong.
 
  In v3, the default for mirror is changed to True for all flows except subscribe, which
  is the least surprising behaviour given the default to False in v2.
   

Features
--------

* sarra.plugin API is now vanilla python with no magic settings. just standard classes, using standard import mechanism.
  debugging should be much simpler now as the interpreter will provide much better error messages on startup.

* properties/options for classes are now hierarchical, so can set debug to specific classes within app.

* sarra.moth class abstracts away AMQP, so messaging protocol becomes pluggable.

* use the sarra. prefix (already present) to replace sr\_ prefix on modules.

* API access to flows. (so can build entirely new programs in python by subclassing.)

* sr ability to select multiple components and configurations to operate on.

* sr list examples is now used to display examples separate from the installed ones.

* sr show is now used to display the parsed configuration.

* messages are acknowledged more quickly, should help with throughput.

* plugin API are now based on groups of messages, rather than individual ones, allowing people
  to organize concurrent work.

* integrity (checksums) are now plugins.

* gather (inlet? sources of messages) are now plugins.

* added typing to options settings, so plugins can declare: size, duration, string, or list.
